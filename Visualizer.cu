#include "Constant.hpp"
#include "Visualizer.cuh"
#include <opencv2/opencv.hpp>
#include <cuda_runtime.h>
#include <stdexcept>
#include <fstream>
#include <vector>
#include <iostream>

#define CHECK_CUDA_VIS(expr) \
    do { \
        cudaError_t err = (expr); \
        if (err != cudaSuccess) { \
            throw std::runtime_error(std::string("CUDA error in visualizer: ") + cudaGetErrorString(err)); \
        } \
    } while (0)
namespace{
    // 使用匿名命名空间代替 static 全局变量，更安全
    bool windows_created = false;
    std::vector<uint8_t> h_color_buffer(INPUT_PIXEL_COUNT * 3);
    std::vector<uint16_t> h_depth_buffer(INPUT_PIXEL_COUNT);
}

void visualize(
    const uint8_t* d_raw_color,
    const uint16_t* d_raw_depth
) {
    // 从 GPU 拷贝数据到 CPU
    CHECK_CUDA_VIS(cudaMemcpy(h_color_buffer.data(), d_raw_color,
        sizeof(uint8_t) * INPUT_PIXEL_COUNT * 3, cudaMemcpyDeviceToHost));
    CHECK_CUDA_VIS(cudaMemcpy(h_depth_buffer.data(), d_raw_depth,
        sizeof(uint16_t) * INPUT_PIXEL_COUNT, cudaMemcpyDeviceToHost));
	 
    // 构造 OpenCV Mat（无拷贝，直接使用 buffer）
    cv::Mat color_mat(INPUT_HEIGHT, INPUT_WIDTH, CV_8UC3, h_color_buffer.data());
    cv::Mat depth_mat(INPUT_HEIGHT, INPUT_WIDTH, CV_16U, h_depth_buffer.data());

    // 转 RGB → BGR（OpenCV 默认 BGR 显示）
    cv::cvtColor(color_mat, color_mat, cv::COLOR_RGB2BGR);

    // 深度图归一化到 0~255（假设有效深度 ≤ 4000mm）
    cv::Mat depth_vis;
    depth_mat.convertTo(depth_vis, CV_8U, 255.0 / 4000.0);

    // 创建窗口（仅首次）
    if (!windows_created) {
        cv::namedWindow("Color", cv::WINDOW_AUTOSIZE);
        cv::namedWindow("Depth", cv::WINDOW_AUTOSIZE);
        windows_created = true;
    }

    // 显示
    cv::imshow("Color", color_mat);
    cv::imshow("Depth", depth_vis);

    // 非阻塞等待 1ms，检测按键
    int key = cv::waitKey(1);
    if (key == 'q' || key == 27) { // 'q' 或 ESC
        cv::destroyAllWindows();
        exit(EXIT_SUCCESS);
    }
}

void savePointCloudToPLY(const PointCloud* d_cloud, int num_points, const char* filename) {
    // 1. 在 CPU 上创建临时缓冲区
    std::vector<float> h_x(num_points);
    std::vector<float> h_y(num_points);
    std::vector<float> h_z(num_points);
    std::vector<uint8_t> h_r(num_points);
    std::vector<uint8_t> h_g(num_points);
    std::vector<uint8_t> h_b(num_points);
    std::vector<uint8_t> h_valid(num_points);

    // 2. 从 GPU 复制数据到 CPU
    CHECK_CUDA_VIS(cudaMemcpy(h_x.data(), d_cloud->x, num_points * sizeof(float), cudaMemcpyDeviceToHost));
    CHECK_CUDA_VIS(cudaMemcpy(h_y.data(), d_cloud->y, num_points * sizeof(float), cudaMemcpyDeviceToHost));
    CHECK_CUDA_VIS(cudaMemcpy(h_z.data(), d_cloud->z, num_points * sizeof(float), cudaMemcpyDeviceToHost));
    CHECK_CUDA_VIS(cudaMemcpy(h_r.data(), d_cloud->r, num_points * sizeof(uint8_t), cudaMemcpyDeviceToHost));
    CHECK_CUDA_VIS(cudaMemcpy(h_g.data(), d_cloud->g, num_points * sizeof(uint8_t), cudaMemcpyDeviceToHost));
    CHECK_CUDA_VIS(cudaMemcpy(h_b.data(), d_cloud->b, num_points * sizeof(uint8_t), cudaMemcpyDeviceToHost));
    CHECK_CUDA_VIS(cudaMemcpy(h_valid.data(), d_cloud->valid, num_points * sizeof(uint8_t), cudaMemcpyDeviceToHost));

    // 3. 统计有效点数量
    int valid_count = 0;
    for (int i = 0; i < num_points; ++i) {
        if (h_valid[i]) valid_count++;
    }

    // 4. 创建 PLY 文件
    std::ofstream file(filename);
    if (!file.is_open()) {
        std::cerr << "Failed to open " << filename << " for writing." << std::endl;
        return;
    }

    // 5. 写入 PLY 头部
    file << "ply\n";
    file << "format ascii 1.0\n";
    file << "comment Generated by CUDA RealSense Point Cloud\n";
    file << "element vertex " << valid_count << "\n";
    file << "property float x\n";
    file << "property float y\n";
    file << "property float z\n";
    file << "property uchar red\n";
    file << "property uchar green\n";
    file << "property uchar blue\n";
    file << "end_header\n";

    // 6. 写入有效点数据
    for (int i = 0; i < num_points; ++i) {
        if (h_valid[i]) {
            // 注意：Blender 使用 Y 轴向上，但 RealSense 使用 Y 轴向下
            // 需要反转 Y 坐标（保持与相机坐标系一致）
            file << h_x[i] << " " << -h_y[i] << " " << h_z[i] << " "
                << static_cast<int>(h_r[i]) << " "
                << static_cast<int>(h_g[i]) << " "
                << static_cast<int>(h_b[i]) << "\n";
        }
    }

    file.close();
    std::cout << "Saved " << valid_count << " points to " << filename << std::endl;
}