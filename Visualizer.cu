#include "Constant.hpp"
#include "Visualizer.cuh"
#include <opencv2/opencv.hpp>
#include <cuda_runtime.h>
#include <stdexcept>
#include <fstream>
#include <vector>
#include <iostream>

#define CHECK_CUDA_VIS(expr) \
    do { \
        cudaError_t err = (expr); \
        if (err != cudaSuccess) { \
            throw std::runtime_error(std::string("CUDA error in visualizer: ") + cudaGetErrorString(err)); \
        } \
    } while (0)
namespace{
    // ʹռ static ȫֱȫ
    bool windows_created = false;
    std::vector<uint8_t> h_color_buffer(INPUT_PIXEL_COUNT * 3);
    std::vector<uint16_t> h_depth_buffer(INPUT_PIXEL_COUNT);
}

void visualize(
    const uint8_t* d_raw_color,
    const uint16_t* d_raw_depth
) {
    //  GPU ݵ CPU
    CHECK_CUDA_VIS(cudaMemcpy(h_color_buffer.data(), d_raw_color,
        sizeof(uint8_t) * INPUT_PIXEL_COUNT * 3, cudaMemcpyDeviceToHost));
    CHECK_CUDA_VIS(cudaMemcpy(h_depth_buffer.data(), d_raw_depth,
        sizeof(uint16_t) * INPUT_PIXEL_COUNT, cudaMemcpyDeviceToHost));
	 
    //  OpenCV Mat޿ֱʹ buffer
    cv::Mat color_mat(INPUT_HEIGHT, INPUT_WIDTH, CV_8UC3, h_color_buffer.data());
    cv::Mat depth_mat(INPUT_HEIGHT, INPUT_WIDTH, CV_16U, h_depth_buffer.data());

    // ת RGB  BGROpenCV Ĭ BGR ʾ
    cv::cvtColor(color_mat, color_mat, cv::COLOR_RGB2BGR);

    // ͼһ 0~255Ч  4000mm
    cv::Mat depth_vis;
    depth_mat.convertTo(depth_vis, CV_8U, 255.0 / 4000.0);

    // ڣ״Σ
    if (!windows_created) {
        cv::namedWindow("Color", cv::WINDOW_AUTOSIZE);
        cv::namedWindow("Depth", cv::WINDOW_AUTOSIZE);
        windows_created = true;
    }

    // ʾ
    cv::imshow("Color", color_mat);
    cv::imshow("Depth", depth_vis);

    // ȴ 1msⰴ
    int key = cv::waitKey(1);
    if (key == 'q' || key == 27) { // 'q'  ESC
        cv::destroyAllWindows();
        exit(EXIT_SUCCESS);
    }
}

void savePointCloudToPLY(const PointCloud* d_cloud, int num_points, const char* filename) {
    // 1.  CPU ϴʱ
    std::vector<float> h_x(num_points);
    std::vector<float> h_y(num_points);
    std::vector<float> h_z(num_points);
    std::vector<uint8_t> h_r(num_points);
    std::vector<uint8_t> h_g(num_points);
    std::vector<uint8_t> h_b(num_points);
    std::vector<uint8_t> h_valid(num_points);

    // 2.  GPU ݵ CPU
    CHECK_CUDA_VIS(cudaMemcpy(h_x.data(), d_cloud->x, num_points * sizeof(float), cudaMemcpyDeviceToHost));
    CHECK_CUDA_VIS(cudaMemcpy(h_y.data(), d_cloud->y, num_points * sizeof(float), cudaMemcpyDeviceToHost));
    CHECK_CUDA_VIS(cudaMemcpy(h_z.data(), d_cloud->z, num_points * sizeof(float), cudaMemcpyDeviceToHost));
    CHECK_CUDA_VIS(cudaMemcpy(h_r.data(), d_cloud->r, num_points * sizeof(uint8_t), cudaMemcpyDeviceToHost));
    CHECK_CUDA_VIS(cudaMemcpy(h_g.data(), d_cloud->g, num_points * sizeof(uint8_t), cudaMemcpyDeviceToHost));
    CHECK_CUDA_VIS(cudaMemcpy(h_b.data(), d_cloud->b, num_points * sizeof(uint8_t), cudaMemcpyDeviceToHost));
    CHECK_CUDA_VIS(cudaMemcpy(h_valid.data(), d_cloud->valid, num_points * sizeof(uint8_t), cudaMemcpyDeviceToHost));

    // 3. ͳЧ
    int valid_count = 0;
    for (int i = 0; i < num_points; ++i) {
        if (h_valid[i]) valid_count++;
    }

    // 4.  PLY ļ
    std::ofstream file(filename);
    if (!file.is_open()) {
        std::cerr << "Failed to open " << filename << " for writing." << std::endl;
        return;
    }

    // 5. д PLY ͷ
    file << "ply\n";
    file << "format ascii 1.0\n";
    file << "comment Generated by CUDA RealSense Point Cloud\n";
    file << "element vertex " << valid_count << "\n";
    file << "property float x\n";
    file << "property float y\n";
    file << "property float z\n";
    file << "property uchar red\n";
    file << "property uchar green\n";
    file << "property uchar blue\n";
    file << "end_header\n";

    // 6. дЧ
    for (int i = 0; i < num_points; ++i) {
        if (h_valid[i]) {
            // ע⣺Blender ʹ Y ϣ RealSense ʹ Y 
            // Ҫת Y ꣨ϵһ£
            file << h_x[i] << " " << -h_y[i] << " " << h_z[i] << " "
                << static_cast<int>(h_r[i]) << " "
                << static_cast<int>(h_g[i]) << " "
                << static_cast<int>(h_b[i]) << "\n";
        }
    }

    file.close();
    std::cout << "Saved " << valid_count << " points to " << filename << std::endl;
}